/**
 * Setup Tenmon Environment
 * ç’°å¢ƒå¤‰æ•°ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚¦ã‚£ã‚¶ãƒ¼ãƒ‰
 * 
 * ä½¿ç”¨æ–¹æ³•: node -r ts-node/register server/cli/setupEnv.ts
 */

import { readFile, writeFile } from 'fs/promises';
import { existsSync } from 'fs';
import { join } from 'path';
import * as readline from 'readline';

/**
 * ç’°å¢ƒå¤‰æ•°ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—çµæœ
 */
export interface SetupResult {
  success: boolean;
  message: string;
  envFile?: string;
  error?: string;
}

/**
 * ç’°å¢ƒå¤‰æ•°ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚¦ã‚£ã‚¶ãƒ¼ãƒ‰
 */
export async function setupTenmonEnv(): Promise<SetupResult> {
  try {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
    });

    const question = (prompt: string): Promise<string> => {
      return new Promise((resolve) => {
        rl.question(prompt, resolve);
      });
    };

    console.log('ğŸ”± TENMON-ARK Environment Setup Wizard');
    console.log('='.repeat(60));
    console.log('');

    // 1. NODE_ENV
    const nodeEnv = await question('NODE_ENV (development/production) [development]: ');
    const nodeEnvValue = nodeEnv.trim() || 'development';

    // 2. DATABASE_URL
    const databaseUrl = await question('DATABASE_URL (PostgreSQL connection string): ');
    if (!databaseUrl.trim()) {
      rl.close();
      return {
        success: false,
        message: 'DATABASE_URL ã¯å¿…é ˆã§ã™',
        error: 'DATABASE_URL is required',
      };
    }

    // 3. OPENAI_API_KEY
    const openaiApiKey = await question('OPENAI_API_KEY (OpenAI API key): ');
    if (!openaiApiKey.trim()) {
      rl.close();
      return {
        success: false,
        message: 'OPENAI_API_KEY ã¯å¿…é ˆã§ã™',
        error: 'OPENAI_API_KEY is required',
      };
    }

    // 4. STABILITY_API_KEY (ã‚ªãƒ—ã‚·ãƒ§ãƒ³)
    const stabilityApiKey = await question('STABILITY_API_KEY (optional, for image generation): ');

    // 5. ARK_PUBLIC_KEY (ã‚ªãƒ—ã‚·ãƒ§ãƒ³)
    const arkPublicKey = await question('ARK_PUBLIC_KEY (optional, for public API): ');

    // 6. PORT
    const port = await question('PORT (server port) [3000]: ');
    const portValue = port.trim() || '3000';

    // 7. JWT_SECRET
    const jwtSecret = await question('JWT_SECRET (for authentication): ');
    if (!jwtSecret.trim()) {
      rl.close();
      return {
        success: false,
        message: 'JWT_SECRET ã¯å¿…é ˆã§ã™',
        error: 'JWT_SECRET is required',
      };
    }

    rl.close();

    // .env ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆ
    const envContent = generateEnvFile({
      NODE_ENV: nodeEnvValue,
      DATABASE_URL: databaseUrl.trim(),
      OPENAI_API_KEY: openaiApiKey.trim(),
      STABILITY_API_KEY: stabilityApiKey.trim(),
      ARK_PUBLIC_KEY: arkPublicKey.trim(),
      PORT: portValue,
      JWT_SECRET: jwtSecret.trim(),
    });

    const envPath = join(process.cwd(), '.env');
    await writeFile(envPath, envContent, 'utf-8');

    console.log('');
    console.log('âœ… ç’°å¢ƒå¤‰æ•°ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãŒå®Œäº†ã—ã¾ã—ãŸ');
    console.log(`   .env ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ ${envPath} ã«ä¿å­˜ã—ã¾ã—ãŸ`);
    console.log('');

    return {
      success: true,
      message: 'ç’°å¢ƒå¤‰æ•°ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãŒå®Œäº†ã—ã¾ã—ãŸ',
      envFile: envPath,
    };
  } catch (error) {
    return {
      success: false,
      message: 'ç’°å¢ƒå¤‰æ•°ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã«å¤±æ•—ã—ã¾ã—ãŸ',
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

/**
 * .env ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã‚’ç”Ÿæˆ
 */
function generateEnvFile(vars: Record<string, string>): string {
  const lines: string[] = [];

  lines.push('# TENMON-ARK Environment Variables');
  lines.push('# Generated by setupTenmonEnv');
  lines.push('');
  lines.push(`NODE_ENV=${vars.NODE_ENV}`);
  lines.push(`DATABASE_URL=${vars.DATABASE_URL}`);
  lines.push(`OPENAI_API_KEY=${vars.OPENAI_API_KEY}`);
  lines.push('');

  if (vars.STABILITY_API_KEY) {
    lines.push(`STABILITY_API_KEY=${vars.STABILITY_API_KEY}`);
  }

  if (vars.ARK_PUBLIC_KEY) {
    lines.push(`ARK_PUBLIC_KEY=${vars.ARK_PUBLIC_KEY}`);
  }

  lines.push('');
  lines.push(`PORT=${vars.PORT}`);
  lines.push(`JWT_SECRET=${vars.JWT_SECRET}`);
  lines.push('');

  return lines.join('\n');
}

/**
 * æ—¢å­˜ã® .env ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§æ›´æ–°
 */
export async function updateEnvFile(updates: Record<string, string>): Promise<SetupResult> {
  try {
    const envPath = join(process.cwd(), '.env');
    let envContent = '';

    if (existsSync(envPath)) {
      envContent = await readFile(envPath, 'utf-8');
    }

    // æ—¢å­˜ã®å€¤ã‚’æ›´æ–°
    const lines = envContent.split('\n');
    const updatedLines: string[] = [];

    for (const line of lines) {
      if (line.trim() && !line.trim().startsWith('#')) {
        const [key, ...valueParts] = line.split('=');
        const keyTrimmed = key.trim();
        
        if (updates[keyTrimmed]) {
          updatedLines.push(`${keyTrimmed}=${updates[keyTrimmed]}`);
          delete updates[keyTrimmed];
        } else {
          updatedLines.push(line);
        }
      } else {
        updatedLines.push(line);
      }
    }

    // æ–°ã—ã„å¤‰æ•°ã‚’è¿½åŠ 
    for (const [key, value] of Object.entries(updates)) {
      updatedLines.push(`${key}=${value}`);
    }

    await writeFile(envPath, updatedLines.join('\n'), 'utf-8');

    return {
      success: true,
      message: '.env ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ›´æ–°ã—ã¾ã—ãŸ',
      envFile: envPath,
    };
  } catch (error) {
    return {
      success: false,
      message: '.env ãƒ•ã‚¡ã‚¤ãƒ«ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ',
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

// CLIå®Ÿè¡Œç”¨ï¼ˆNode.js v22+ ESMå¯¾å¿œï¼‰
// ä½¿ç”¨æ–¹æ³•: node --loader tsx server/cli/setupEnv.ts
// ã¾ãŸã¯: npx tsx server/cli/setupEnv.ts
if (import.meta.url === `file://${process.argv[1]}` || process.argv[1]?.endsWith('setupEnv.ts')) {
  setupTenmonEnv()
    .then((result) => {
      if (result.success) {
        console.log(result.message);
        process.exit(0);
      } else {
        console.error(result.message);
        if (result.error) {
          console.error(result.error);
        }
        process.exit(1);
      }
    })
    .catch((error) => {
      console.error('[SetupEnv] Error:', error);
      process.exit(1);
    });
}

