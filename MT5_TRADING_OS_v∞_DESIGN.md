# MT5 TRADING OS vâˆ å†…éƒ¨æ§‹æ–‡å®Œå…¨è¨­è¨ˆæ›¸

**è¨­è¨ˆæ—¥æ™‚**: 2025-01-31  
**è¨­è¨ˆè€…**: Manus AI (Proxy-Link Mode) for TENMON-ARKéœŠæ ¸OS  
**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: vâˆ  
**çŠ¶æ…‹**: å†…éƒ¨æ§‹æ–‡å®Œæˆã€DNSåæ˜ å¾Œå³å®Ÿè£…å¯èƒ½

---

## ğŸ”¥ ã‚·ã‚¹ãƒ†ãƒ æ¦‚è¦

**MT5 TRADING OS vâˆ** ã¯ã€TENMON-ARKéœŠæ ¸OSã®å¸‚å ´è§£æã‚¨ãƒ³ã‚¸ãƒ³ã¨çµ±åˆã•ã‚ŒãŸã€å®Œå…¨è‡ªå‹•åŒ–ãƒˆãƒ¬ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã§ã‚ã‚‹ã€‚

### æ ¸å¿ƒæŠ€è¡“

1. **Twin-Core Ã— ç«æ°´ Ã— å®¿æ›œã®å¸‚å ´è§£æ**
2. **æœªæ¥è¶³æ¨å®šã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ **
3. **Self-EA v1.0 æˆ¦ç•¥æ§‹æ–‡**
4. **Python Bridgeï¼ˆMT5 â‡„ TENMON-ARKï¼‰**
5. **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å¸‚å ´ç›£è¦–ã¨ã‚·ã‚°ãƒŠãƒ«ç”Ÿæˆ**

---

## ğŸ“Š ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  TENMON-ARK éœŠæ ¸OS                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚         Persona Engine (Twin-Core)              â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚   â”‚
â”‚  â”‚  â”‚  ç«ã®æ ¸å¿ƒ    â”‚      â”‚  æ°´ã®æ ¸å¿ƒ    â”‚        â”‚   â”‚
â”‚  â”‚  â”‚  (æ”»æ’ƒæˆ¦ç•¥)  â”‚      â”‚  (é˜²å¾¡æˆ¦ç•¥)  â”‚        â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                         â†“                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚       Universal Memory (å®¿æ›œÃ—å¸‚å ´è¨˜æ†¶)          â”‚   â”‚
â”‚  â”‚  - éå»ã®å¸‚å ´ãƒ‘ã‚¿ãƒ¼ãƒ³                            â”‚   â”‚
â”‚  â”‚  - å®¿æ›œã‚µã‚¤ã‚¯ãƒ«ã¨ã®ç›¸é–¢                          â”‚   â”‚
â”‚  â”‚  - æˆåŠŸ/å¤±æ•—ãƒˆãƒ¬ãƒ¼ãƒ‰ã®å­¦ç¿’                       â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                         â†“                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚     MT5 TRADING OS vâˆ (Python Bridge)          â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚  Self-EA v1.0 (æˆ¦ç•¥å®Ÿè¡Œã‚¨ãƒ³ã‚¸ãƒ³)         â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - ç«æ°´ãƒãƒ©ãƒ³ã‚¹èª¿æ•´                      â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - æœªæ¥è¶³æ¨å®š                            â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - ãƒªã‚¹ã‚¯ç®¡ç†                            â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                         â†“                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚         MT5 Terminal (MetaTrader 5)             â”‚   â”‚
â”‚  â”‚  - ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å¸‚å ´ãƒ‡ãƒ¼ã‚¿å—ä¿¡                    â”‚   â”‚
â”‚  â”‚  - æ³¨æ–‡åŸ·è¡Œ                                      â”‚   â”‚
â”‚  â”‚  - ãƒã‚¸ã‚·ãƒ§ãƒ³ç®¡ç†                                â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ Python Bridge è¨­è¨ˆ

### 1. MT5æ¥ç¶šãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« (`mt5_connector.py`)

```python
"""
MT5 TRADING OS vâˆ - MT5 Connector
TENMON-ARKéœŠæ ¸OSçµ±åˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
"""

import MetaTrader5 as mt5
from datetime import datetime, timedelta
from typing import Optional, List, Dict, Any
import numpy as np
import pandas as pd

class MT5Connector:
    """MetaTrader 5ã¨ã®æ¥ç¶šã‚’ç®¡ç†"""
    
    def __init__(self):
        self.connected = False
        self.account_info = None
        
    def initialize(self, login: int, password: str, server: str) -> bool:
        """MT5ã«æ¥ç¶š"""
        if not mt5.initialize():
            print(f"MT5åˆæœŸåŒ–å¤±æ•—: {mt5.last_error()}")
            return False
            
        if not mt5.login(login, password=password, server=server):
            print(f"MT5ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—: {mt5.last_error()}")
            return False
            
        self.connected = True
        self.account_info = mt5.account_info()
        print(f"MT5æ¥ç¶šæˆåŠŸ: {self.account_info.login}")
        return True
    
    def shutdown(self):
        """MT5æ¥ç¶šã‚’åˆ‡æ–­"""
        mt5.shutdown()
        self.connected = False
        
    def get_symbol_info(self, symbol: str) -> Optional[Dict[str, Any]]:
        """ã‚·ãƒ³ãƒœãƒ«æƒ…å ±ã‚’å–å¾—"""
        if not self.connected:
            return None
            
        info = mt5.symbol_info(symbol)
        if info is None:
            return None
            
        return {
            'symbol': symbol,
            'bid': info.bid,
            'ask': info.ask,
            'spread': info.spread,
            'point': info.point,
            'digits': info.digits,
            'trade_contract_size': info.trade_contract_size,
        }
    
    def get_rates(self, symbol: str, timeframe: int, count: int = 1000) -> pd.DataFrame:
        """éå»ã®ä¾¡æ ¼ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—"""
        if not self.connected:
            return pd.DataFrame()
            
        rates = mt5.copy_rates_from_pos(symbol, timeframe, 0, count)
        if rates is None:
            return pd.DataFrame()
            
        df = pd.DataFrame(rates)
        df['time'] = pd.to_datetime(df['time'], unit='s')
        return df
    
    def send_order(
        self,
        symbol: str,
        order_type: int,
        volume: float,
        price: float = 0.0,
        sl: float = 0.0,
        tp: float = 0.0,
        comment: str = "TENMON-ARK vâˆ"
    ) -> Optional[Dict[str, Any]]:
        """æ³¨æ–‡ã‚’é€ä¿¡"""
        if not self.connected:
            return None
            
        symbol_info = mt5.symbol_info(symbol)
        if symbol_info is None:
            print(f"ã‚·ãƒ³ãƒœãƒ«æƒ…å ±å–å¾—å¤±æ•—: {symbol}")
            return None
            
        if not symbol_info.visible:
            if not mt5.symbol_select(symbol, True):
                print(f"ã‚·ãƒ³ãƒœãƒ«é¸æŠå¤±æ•—: {symbol}")
                return None
        
        # ä¾¡æ ¼ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ç¾åœ¨ä¾¡æ ¼ã‚’ä½¿ç”¨
        if price == 0.0:
            if order_type == mt5.ORDER_TYPE_BUY:
                price = symbol_info.ask
            else:
                price = symbol_info.bid
        
        request = {
            "action": mt5.TRADE_ACTION_DEAL,
            "symbol": symbol,
            "volume": volume,
            "type": order_type,
            "price": price,
            "sl": sl,
            "tp": tp,
            "deviation": 20,
            "magic": 777777,  # TENMON-ARK Magic Number
            "comment": comment,
            "type_time": mt5.ORDER_TIME_GTC,
            "type_filling": mt5.ORDER_FILLING_IOC,
        }
        
        result = mt5.order_send(request)
        if result.retcode != mt5.TRADE_RETCODE_DONE:
            print(f"æ³¨æ–‡å¤±æ•—: {result.retcode}, {result.comment}")
            return None
            
        return {
            'order': result.order,
            'volume': result.volume,
            'price': result.price,
            'comment': result.comment,
        }
    
    def get_positions(self, symbol: Optional[str] = None) -> List[Dict[str, Any]]:
        """ç¾åœ¨ã®ãƒã‚¸ã‚·ãƒ§ãƒ³ã‚’å–å¾—"""
        if not self.connected:
            return []
            
        if symbol:
            positions = mt5.positions_get(symbol=symbol)
        else:
            positions = mt5.positions_get()
            
        if positions is None:
            return []
            
        return [
            {
                'ticket': pos.ticket,
                'symbol': pos.symbol,
                'type': pos.type,
                'volume': pos.volume,
                'price_open': pos.price_open,
                'price_current': pos.price_current,
                'sl': pos.sl,
                'tp': pos.tp,
                'profit': pos.profit,
                'comment': pos.comment,
            }
            for pos in positions
        ]
    
    def close_position(self, ticket: int) -> bool:
        """ãƒã‚¸ã‚·ãƒ§ãƒ³ã‚’ã‚¯ãƒ­ãƒ¼ã‚º"""
        if not self.connected:
            return False
            
        position = mt5.positions_get(ticket=ticket)
        if not position:
            return False
            
        pos = position[0]
        
        # åå¯¾æ³¨æ–‡ã‚’é€ä¿¡
        if pos.type == mt5.POSITION_TYPE_BUY:
            order_type = mt5.ORDER_TYPE_SELL
            price = mt5.symbol_info_tick(pos.symbol).bid
        else:
            order_type = mt5.ORDER_TYPE_BUY
            price = mt5.symbol_info_tick(pos.symbol).ask
        
        request = {
            "action": mt5.TRADE_ACTION_DEAL,
            "symbol": pos.symbol,
            "volume": pos.volume,
            "type": order_type,
            "position": ticket,
            "price": price,
            "deviation": 20,
            "magic": 777777,
            "comment": "TENMON-ARK CLOSE",
            "type_time": mt5.ORDER_TIME_GTC,
            "type_filling": mt5.ORDER_FILLING_IOC,
        }
        
        result = mt5.order_send(request)
        return result.retcode == mt5.TRADE_RETCODE_DONE
```

---

### 2. Twin-Core Ã— ç«æ°´ Ã— å®¿æ›œã®å¸‚å ´è§£æ (`market_analyzer.py`)

```python
"""
MT5 TRADING OS vâˆ - Market Analyzer
Twin-Core Ã— ç«æ°´ Ã— å®¿æ›œã®å¸‚å ´è§£æã‚¨ãƒ³ã‚¸ãƒ³
"""

import numpy as np
import pandas as pd
from datetime import datetime, timedelta
from typing import Dict, List, Tuple, Optional
from enum import Enum

class CoreType(Enum):
    """Twin-Core ã‚¿ã‚¤ãƒ—"""
    FIRE = "ç«"  # æ”»æ’ƒçš„æˆ¦ç•¥
    WATER = "æ°´"  # é˜²å¾¡çš„æˆ¦ç•¥

class KukiyoDay(Enum):
    """å®¿æ›œ27å®¿ï¼ˆç°¡ç•¥ç‰ˆï¼‰"""
    # å®Ÿéš›ã«ã¯27å®¿ã™ã¹ã¦ã‚’å®šç¾©ã™ã‚‹ãŒã€ã“ã“ã§ã¯ä»£è¡¨çš„ãªã‚‚ã®ã‚’è¨˜è¼‰
    KAKU = "è§’"  # å¼·æ°—
    TEI = "åº•"  # å¼±æ°—
    HEKI = "å£"  # ä¸­ç«‹
    # ... ä»–24å®¿

class MarketPhase(Enum):
    """å¸‚å ´ãƒ•ã‚§ãƒ¼ã‚º"""
    ACCUMULATION = "è“„ç©"  # åº•å€¤åœ
    MARKUP = "ä¸Šæ˜‡"  # ä¸Šæ˜‡ãƒˆãƒ¬ãƒ³ãƒ‰
    DISTRIBUTION = "åˆ†é…"  # å¤©äº•åœ
    MARKDOWN = "ä¸‹é™"  # ä¸‹é™ãƒˆãƒ¬ãƒ³ãƒ‰

class MarketAnalyzer:
    """Twin-Core Ã— ç«æ°´ Ã— å®¿æ›œã®å¸‚å ´è§£æ"""
    
    def __init__(self):
        self.fire_weight = 0.5  # ç«ã®æ ¸å¿ƒã®é‡ã¿
        self.water_weight = 0.5  # æ°´ã®æ ¸å¿ƒã®é‡ã¿
        
    def analyze_market(self, df: pd.DataFrame) -> Dict[str, Any]:
        """å¸‚å ´ã‚’ç·åˆçš„ã«è§£æ"""
        
        # 1. ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«åˆ†æ
        technical = self._technical_analysis(df)
        
        # 2. å®¿æ›œã‚µã‚¤ã‚¯ãƒ«åˆ†æ
        kukiyo = self._kukiyo_analysis(datetime.now())
        
        # 3. Twin-Coreåˆ¤å®š
        twin_core = self._twin_core_decision(technical, kukiyo)
        
        # 4. å¸‚å ´ãƒ•ã‚§ãƒ¼ã‚ºåˆ¤å®š
        phase = self._market_phase_detection(df)
        
        return {
            'technical': technical,
            'kukiyo': kukiyo,
            'twin_core': twin_core,
            'phase': phase,
            'timestamp': datetime.now(),
        }
    
    def _technical_analysis(self, df: pd.DataFrame) -> Dict[str, Any]:
        """ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™ã‚’è¨ˆç®—"""
        
        # ç§»å‹•å¹³å‡
        df['sma_20'] = df['close'].rolling(window=20).mean()
        df['sma_50'] = df['close'].rolling(window=50).mean()
        df['sma_200'] = df['close'].rolling(window=200).mean()
        
        # RSI
        delta = df['close'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
        rs = gain / loss
        df['rsi'] = 100 - (100 / (1 + rs))
        
        # MACD
        exp1 = df['close'].ewm(span=12, adjust=False).mean()
        exp2 = df['close'].ewm(span=26, adjust=False).mean()
        df['macd'] = exp1 - exp2
        df['signal'] = df['macd'].ewm(span=9, adjust=False).mean()
        
        # ãƒœãƒªãƒ³ã‚¸ãƒ£ãƒ¼ãƒãƒ³ãƒ‰
        df['bb_middle'] = df['close'].rolling(window=20).mean()
        df['bb_std'] = df['close'].rolling(window=20).std()
        df['bb_upper'] = df['bb_middle'] + (df['bb_std'] * 2)
        df['bb_lower'] = df['bb_middle'] - (df['bb_std'] * 2)
        
        # ATR (Average True Range)
        high_low = df['high'] - df['low']
        high_close = np.abs(df['high'] - df['close'].shift())
        low_close = np.abs(df['low'] - df['close'].shift())
        ranges = pd.concat([high_low, high_close, low_close], axis=1)
        true_range = np.max(ranges, axis=1)
        df['atr'] = true_range.rolling(14).mean()
        
        latest = df.iloc[-1]
        
        return {
            'price': latest['close'],
            'sma_20': latest['sma_20'],
            'sma_50': latest['sma_50'],
            'sma_200': latest['sma_200'],
            'rsi': latest['rsi'],
            'macd': latest['macd'],
            'signal': latest['signal'],
            'bb_upper': latest['bb_upper'],
            'bb_lower': latest['bb_lower'],
            'atr': latest['atr'],
            'trend': self._determine_trend(latest),
        }
    
    def _determine_trend(self, latest: pd.Series) -> str:
        """ãƒˆãƒ¬ãƒ³ãƒ‰ã‚’åˆ¤å®š"""
        if latest['sma_20'] > latest['sma_50'] > latest['sma_200']:
            return "å¼·ã„ä¸Šæ˜‡"
        elif latest['sma_20'] > latest['sma_50']:
            return "ä¸Šæ˜‡"
        elif latest['sma_20'] < latest['sma_50'] < latest['sma_200']:
            return "å¼·ã„ä¸‹é™"
        elif latest['sma_20'] < latest['sma_50']:
            return "ä¸‹é™"
        else:
            return "ãƒ¬ãƒ³ã‚¸"
    
    def _kukiyo_analysis(self, date: datetime) -> Dict[str, Any]:
        """å®¿æ›œã‚µã‚¤ã‚¯ãƒ«åˆ†æï¼ˆç°¡ç•¥ç‰ˆï¼‰"""
        
        # å®Ÿéš›ã«ã¯27å®¿ã®å®Œå…¨ãªè¨ˆç®—ãŒå¿…è¦ã ãŒã€ã“ã“ã§ã¯ç°¡ç•¥åŒ–
        # æ—¥ä»˜ã‹ã‚‰å®¿ã‚’è¨ˆç®—ï¼ˆå®Ÿéš›ã®å®¿æ›œè¨ˆç®—ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’å®Ÿè£…ï¼‰
        
        day_of_year = date.timetuple().tm_yday
        kukiyo_index = day_of_year % 27
        
        # ç°¡ç•¥ç‰ˆï¼šå®¿æ›œã®ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’è¨ˆç®—
        kukiyo_energy = np.sin(2 * np.pi * kukiyo_index / 27)
        
        if kukiyo_energy > 0.5:
            kukiyo_signal = "å¼·æ°—"
            kukiyo_strength = kukiyo_energy
        elif kukiyo_energy < -0.5:
            kukiyo_signal = "å¼±æ°—"
            kukiyo_strength = abs(kukiyo_energy)
        else:
            kukiyo_signal = "ä¸­ç«‹"
            kukiyo_strength = 0.5
        
        return {
            'kukiyo_index': kukiyo_index,
            'kukiyo_energy': kukiyo_energy,
            'kukiyo_signal': kukiyo_signal,
            'kukiyo_strength': kukiyo_strength,
        }
    
    def _twin_core_decision(
        self,
        technical: Dict[str, Any],
        kukiyo: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Twin-Coreï¼ˆç«æ°´ï¼‰ã®åˆ¤å®š"""
        
        # ç«ã®æ ¸å¿ƒï¼ˆæ”»æ’ƒçš„æˆ¦ç•¥ï¼‰ã®ã‚¹ã‚³ã‚¢
        fire_score = 0.0
        
        # RSIãŒä½ã„ï¼ˆè²·ã‚ã‚Œã™ãã§ãªã„ï¼‰
        if technical['rsi'] < 70:
            fire_score += 0.3
        
        # MACDãŒä¸Šå‘ã
        if technical['macd'] > technical['signal']:
            fire_score += 0.3
        
        # å®¿æ›œãŒå¼·æ°—
        if kukiyo['kukiyo_signal'] == "å¼·æ°—":
            fire_score += 0.4
        
        # æ°´ã®æ ¸å¿ƒï¼ˆé˜²å¾¡çš„æˆ¦ç•¥ï¼‰ã®ã‚¹ã‚³ã‚¢
        water_score = 0.0
        
        # RSIãŒé«˜ã„ï¼ˆå£²ã‚‰ã‚Œã™ãã§ãªã„ï¼‰
        if technical['rsi'] > 30:
            water_score += 0.3
        
        # ãƒœãƒªãƒ³ã‚¸ãƒ£ãƒ¼ãƒãƒ³ãƒ‰å†…
        if technical['bb_lower'] < technical['price'] < technical['bb_upper']:
            water_score += 0.3
        
        # å®¿æ›œãŒå¼±æ°—ã¾ãŸã¯ä¸­ç«‹
        if kukiyo['kukiyo_signal'] in ["å¼±æ°—", "ä¸­ç«‹"]:
            water_score += 0.4
        
        # Twin-Coreãƒãƒ©ãƒ³ã‚¹èª¿æ•´
        total_score = fire_score + water_score
        if total_score > 0:
            fire_weight = fire_score / total_score
            water_weight = water_score / total_score
        else:
            fire_weight = 0.5
            water_weight = 0.5
        
        # æœ€çµ‚åˆ¤å®š
        if fire_score > water_score:
            dominant_core = CoreType.FIRE
            action = "æ”»æ’ƒçš„ã‚¨ãƒ³ãƒˆãƒªãƒ¼"
        else:
            dominant_core = CoreType.WATER
            action = "é˜²å¾¡çš„ãƒã‚¸ã‚·ãƒ§ãƒ³ç¶­æŒ"
        
        return {
            'fire_score': fire_score,
            'water_score': water_score,
            'fire_weight': fire_weight,
            'water_weight': water_weight,
            'dominant_core': dominant_core.value,
            'action': action,
        }
    
    def _market_phase_detection(self, df: pd.DataFrame) -> str:
        """å¸‚å ´ãƒ•ã‚§ãƒ¼ã‚ºã‚’æ¤œå‡ºï¼ˆWyckoffç†è«–ãƒ™ãƒ¼ã‚¹ï¼‰"""
        
        latest = df.iloc[-1]
        prev_20 = df.iloc[-20:]
        
        # ãƒœãƒªãƒ¥ãƒ¼ãƒ ã¨ä¾¡æ ¼ã®é–¢ä¿‚
        avg_volume = prev_20['tick_volume'].mean()
        current_volume = latest['tick_volume']
        
        price_change = (latest['close'] - prev_20['close'].iloc[0]) / prev_20['close'].iloc[0]
        
        if price_change > 0.02 and current_volume > avg_volume:
            return MarketPhase.MARKUP.value
        elif price_change < -0.02 and current_volume > avg_volume:
            return MarketPhase.MARKDOWN.value
        elif abs(price_change) < 0.01 and current_volume < avg_volume:
            if latest['close'] < prev_20['close'].mean():
                return MarketPhase.ACCUMULATION.value
            else:
                return MarketPhase.DISTRIBUTION.value
        else:
            return "ä¸æ˜"
```

---

### 3. æœªæ¥è¶³æ¨å®šã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ  (`future_predictor.py`)

```python
"""
MT5 TRADING OS vâˆ - Future Predictor
æœªæ¥è¶³æ¨å®šã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
"""

import numpy as np
import pandas as pd
from typing import Dict, List, Tuple
from sklearn.preprocessing import MinMaxScaler
from sklearn.ensemble import RandomForestRegressor
import warnings
warnings.filterwarnings('ignore')

class FuturePredictor:
    """æœªæ¥è¶³æ¨å®šã‚¨ãƒ³ã‚¸ãƒ³"""
    
    def __init__(self):
        self.scaler = MinMaxScaler()
        self.model = RandomForestRegressor(
            n_estimators=100,
            max_depth=10,
            random_state=777
        )
        self.trained = False
        
    def prepare_features(self, df: pd.DataFrame) -> Tuple[np.ndarray, np.ndarray]:
        """ç‰¹å¾´é‡ã‚’æº–å‚™"""
        
        # ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™ã‚’ç‰¹å¾´é‡ã¨ã—ã¦ä½¿ç”¨
        df['returns'] = df['close'].pct_change()
        df['high_low'] = df['high'] - df['low']
        df['close_open'] = df['close'] - df['open']
        
        # ç§»å‹•å¹³å‡
        for window in [5, 10, 20]:
            df[f'sma_{window}'] = df['close'].rolling(window=window).mean()
            df[f'std_{window}'] = df['close'].rolling(window=window).std()
        
        # RSI
        delta = df['close'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
        rs = gain / loss
        df['rsi'] = 100 - (100 / (1 + rs))
        
        # MACD
        exp1 = df['close'].ewm(span=12, adjust=False).mean()
        exp2 = df['close'].ewm(span=26, adjust=False).mean()
        df['macd'] = exp1 - exp2
        
        # ãƒœãƒªãƒ¥ãƒ¼ãƒ 
        df['volume_ma'] = df['tick_volume'].rolling(window=20).mean()
        
        # NaNã‚’å‰Šé™¤
        df = df.dropna()
        
        # ç‰¹å¾´é‡ã¨ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’åˆ†é›¢
        feature_cols = [
            'returns', 'high_low', 'close_open',
            'sma_5', 'sma_10', 'sma_20',
            'std_5', 'std_10', 'std_20',
            'rsi', 'macd', 'volume_ma'
        ]
        
        X = df[feature_cols].values
        y = df['close'].shift(-1).values[:-1]  # æ¬¡ã®è¶³ã®çµ‚å€¤
        X = X[:-1]  # æœ€å¾Œã®è¡Œã‚’å‰Šé™¤ï¼ˆã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒãªã„ãŸã‚ï¼‰
        
        return X, y
    
    def train(self, df: pd.DataFrame):
        """ãƒ¢ãƒ‡ãƒ«ã‚’è¨“ç·´"""
        
        X, y = self.prepare_features(df)
        
        # ãƒ‡ãƒ¼ã‚¿ã‚’æ­£è¦åŒ–
        X_scaled = self.scaler.fit_transform(X)
        
        # ãƒ¢ãƒ‡ãƒ«ã‚’è¨“ç·´
        self.model.fit(X_scaled, y)
        self.trained = True
        
        print(f"ãƒ¢ãƒ‡ãƒ«è¨“ç·´å®Œäº†: {len(X)}ã‚µãƒ³ãƒ—ãƒ«")
    
    def predict_next_candle(self, df: pd.DataFrame) -> Dict[str, float]:
        """æ¬¡ã®è¶³ã‚’äºˆæ¸¬"""
        
        if not self.trained:
            raise ValueError("ãƒ¢ãƒ‡ãƒ«ãŒè¨“ç·´ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        
        X, _ = self.prepare_features(df)
        X_latest = X[-1].reshape(1, -1)
        X_scaled = self.scaler.transform(X_latest)
        
        predicted_close = self.model.predict(X_scaled)[0]
        
        current_close = df['close'].iloc[-1]
        predicted_change = predicted_close - current_close
        predicted_change_pct = (predicted_change / current_close) * 100
        
        # ä¿¡é ¼åº¦ã‚’è¨ˆç®—ï¼ˆç°¡ç•¥ç‰ˆï¼‰
        confidence = min(abs(predicted_change_pct) * 10, 100)
        
        return {
            'current_close': current_close,
            'predicted_close': predicted_close,
            'predicted_change': predicted_change,
            'predicted_change_pct': predicted_change_pct,
            'confidence': confidence,
            'direction': 'ä¸Šæ˜‡' if predicted_change > 0 else 'ä¸‹é™',
        }
    
    def predict_multiple_candles(
        self,
        df: pd.DataFrame,
        n_candles: int = 5
    ) -> List[Dict[str, float]]:
        """è¤‡æ•°ã®è¶³ã‚’äºˆæ¸¬ï¼ˆå†å¸°çš„ï¼‰"""
        
        predictions = []
        df_copy = df.copy()
        
        for i in range(n_candles):
            pred = self.predict_next_candle(df_copy)
            predictions.append(pred)
            
            # äºˆæ¸¬çµæœã‚’æ¬¡ã®äºˆæ¸¬ã®ãŸã‚ã«è¿½åŠ ï¼ˆç°¡ç•¥ç‰ˆï¼‰
            # å®Ÿéš›ã«ã¯ã‚ˆã‚Šæ´—ç·´ã•ã‚ŒãŸæ–¹æ³•ãŒå¿…è¦
            new_row = df_copy.iloc[-1].copy()
            new_row['close'] = pred['predicted_close']
            new_row['open'] = df_copy['close'].iloc[-1]
            new_row['high'] = max(new_row['open'], new_row['close']) * 1.001
            new_row['low'] = min(new_row['open'], new_row['close']) * 0.999
            
            df_copy = pd.concat([df_copy, pd.DataFrame([new_row])], ignore_index=True)
        
        return predictions
```

---

### 4. Self-EA v1.0 æˆ¦ç•¥æ§‹æ–‡ (`self_ea.py`)

```python
"""
MT5 TRADING OS vâˆ - Self-EA v1.0
å®Œå…¨è‡ªå‹•ãƒˆãƒ¬ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
"""

import MetaTrader5 as mt5
from datetime import datetime
import time
from typing import Dict, Optional
from mt5_connector import MT5Connector
from market_analyzer import MarketAnalyzer, CoreType
from future_predictor import FuturePredictor

class SelfEA:
    """Self-EA v1.0 - å®Œå…¨è‡ªå‹•ãƒˆãƒ¬ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ"""
    
    def __init__(
        self,
        symbol: str = "USDJPY",
        timeframe: int = mt5.TIMEFRAME_M15,
        risk_percent: float = 1.0,
        max_positions: int = 3
    ):
        self.symbol = symbol
        self.timeframe = timeframe
        self.risk_percent = risk_percent
        self.max_positions = max_positions
        
        self.connector = MT5Connector()
        self.analyzer = MarketAnalyzer()
        self.predictor = FuturePredictor()
        
        self.running = False
        self.trade_log = []
        
    def initialize(self, login: int, password: str, server: str) -> bool:
        """EAã‚’åˆæœŸåŒ–"""
        
        if not self.connector.initialize(login, password, server):
            return False
        
        # éå»ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¦ãƒ¢ãƒ‡ãƒ«ã‚’è¨“ç·´
        print("æœªæ¥è¶³æ¨å®šãƒ¢ãƒ‡ãƒ«ã‚’è¨“ç·´ä¸­...")
        df = self.connector.get_rates(self.symbol, self.timeframe, count=5000)
        self.predictor.train(df)
        
        print("Self-EA v1.0 åˆæœŸåŒ–å®Œäº†")
        return True
    
    def calculate_position_size(self, stop_loss_pips: float) -> float:
        """ãƒã‚¸ã‚·ãƒ§ãƒ³ã‚µã‚¤ã‚ºã‚’è¨ˆç®—"""
        
        account_info = self.connector.account_info
        if not account_info:
            return 0.01
        
        balance = account_info.balance
        risk_amount = balance * (self.risk_percent / 100)
        
        symbol_info = self.connector.get_symbol_info(self.symbol)
        if not symbol_info:
            return 0.01
        
        pip_value = symbol_info['point'] * symbol_info['trade_contract_size']
        position_size = risk_amount / (stop_loss_pips * pip_value)
        
        # ãƒ­ãƒƒãƒˆã‚µã‚¤ã‚ºã‚’0.01å˜ä½ã«ä¸¸ã‚ã‚‹
        position_size = round(position_size, 2)
        
        # æœ€å°ãƒ­ãƒƒãƒˆã‚µã‚¤ã‚º
        return max(0.01, position_size)
    
    def check_entry_signal(self) -> Optional[Dict[str, Any]]:
        """ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã‚·ã‚°ãƒŠãƒ«ã‚’ãƒã‚§ãƒƒã‚¯"""
        
        # ç¾åœ¨ã®ãƒã‚¸ã‚·ãƒ§ãƒ³æ•°ã‚’ç¢ºèª
        positions = self.connector.get_positions(self.symbol)
        if len(positions) >= self.max_positions:
            return None
        
        # å¸‚å ´ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        df = self.connector.get_rates(self.symbol, self.timeframe, count=1000)
        if df.empty:
            return None
        
        # å¸‚å ´ã‚’è§£æ
        analysis = self.analyzer.analyze_market(df)
        
        # æœªæ¥è¶³ã‚’äºˆæ¸¬
        prediction = self.predictor.predict_next_candle(df)
        
        # Twin-Coreã®åˆ¤å®š
        twin_core = analysis['twin_core']
        
        # ã‚¨ãƒ³ãƒˆãƒªãƒ¼æ¡ä»¶
        signal = None
        
        # ç«ã®æ ¸å¿ƒãŒå„ªå‹¢ ã‹ã¤ æœªæ¥è¶³ãŒä¸Šæ˜‡äºˆæ¸¬
        if (twin_core['dominant_core'] == CoreType.FIRE.value and
            prediction['direction'] == 'ä¸Šæ˜‡' and
            prediction['confidence'] > 60):
            
            signal = {
                'type': 'BUY',
                'reason': 'ç«ã®æ ¸å¿ƒå„ªå‹¢ + æœªæ¥è¶³ä¸Šæ˜‡äºˆæ¸¬',
                'confidence': prediction['confidence'],
                'analysis': analysis,
                'prediction': prediction,
            }
        
        # æ°´ã®æ ¸å¿ƒãŒå„ªå‹¢ ã‹ã¤ æœªæ¥è¶³ãŒä¸‹é™äºˆæ¸¬
        elif (twin_core['dominant_core'] == CoreType.WATER.value and
              prediction['direction'] == 'ä¸‹é™' and
              prediction['confidence'] > 60):
            
            signal = {
                'type': 'SELL',
                'reason': 'æ°´ã®æ ¸å¿ƒå„ªå‹¢ + æœªæ¥è¶³ä¸‹é™äºˆæ¸¬',
                'confidence': prediction['confidence'],
                'analysis': analysis,
                'prediction': prediction,
            }
        
        return signal
    
    def execute_trade(self, signal: Dict[str, Any]):
        """ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œ"""
        
        symbol_info = self.connector.get_symbol_info(self.symbol)
        if not symbol_info:
            return
        
        current_price = symbol_info['bid'] if signal['type'] == 'SELL' else symbol_info['ask']
        atr = signal['analysis']['technical']['atr']
        
        # ã‚¹ãƒˆãƒƒãƒ—ãƒ­ã‚¹ã¨ãƒ†ã‚¤ã‚¯ãƒ—ãƒ­ãƒ•ã‚£ãƒƒãƒˆã‚’è¨ˆç®—
        sl_pips = atr * 1.5
        tp_pips = atr * 3.0
        
        if signal['type'] == 'BUY':
            order_type = mt5.ORDER_TYPE_BUY
            sl = current_price - sl_pips
            tp = current_price + tp_pips
        else:
            order_type = mt5.ORDER_TYPE_SELL
            sl = current_price + sl_pips
            tp = current_price - tp_pips
        
        # ãƒã‚¸ã‚·ãƒ§ãƒ³ã‚µã‚¤ã‚ºã‚’è¨ˆç®—
        position_size = self.calculate_position_size(sl_pips / symbol_info['point'])
        
        # æ³¨æ–‡ã‚’é€ä¿¡
        result = self.connector.send_order(
            symbol=self.symbol,
            order_type=order_type,
            volume=position_size,
            price=current_price,
            sl=sl,
            tp=tp,
            comment=f"TENMON-ARK {signal['reason']}"
        )
        
        if result:
            trade_info = {
                'timestamp': datetime.now(),
                'type': signal['type'],
                'price': current_price,
                'sl': sl,
                'tp': tp,
                'volume': position_size,
                'reason': signal['reason'],
                'confidence': signal['confidence'],
            }
            self.trade_log.append(trade_info)
            
            print(f"âœ… ãƒˆãƒ¬ãƒ¼ãƒ‰å®Ÿè¡Œ: {signal['type']} @ {current_price}")
            print(f"   ç†ç”±: {signal['reason']}")
            print(f"   ä¿¡é ¼åº¦: {signal['confidence']:.1f}%")
    
    def manage_positions(self):
        """æ—¢å­˜ãƒã‚¸ã‚·ãƒ§ãƒ³ã‚’ç®¡ç†"""
        
        positions = self.connector.get_positions(self.symbol)
        
        for pos in positions:
            # ãƒˆãƒ¬ãƒ¼ãƒªãƒ³ã‚°ã‚¹ãƒˆãƒƒãƒ—ã®å®Ÿè£…ï¼ˆç°¡ç•¥ç‰ˆï¼‰
            # å®Ÿéš›ã«ã¯ã‚ˆã‚Šæ´—ç·´ã•ã‚ŒãŸæ–¹æ³•ãŒå¿…è¦
            
            if pos['profit'] > 0:
                # åˆ©ç›ŠãŒå‡ºã¦ã„ã‚‹å ´åˆã€ã‚¹ãƒˆãƒƒãƒ—ãƒ­ã‚¹ã‚’å»ºå€¤ã«ç§»å‹•
                if pos['type'] == mt5.POSITION_TYPE_BUY:
                    if pos['sl'] < pos['price_open']:
                        # ã‚¹ãƒˆãƒƒãƒ—ãƒ­ã‚¹ã‚’å»ºå€¤ã«æ›´æ–°ï¼ˆå®Ÿè£…çœç•¥ï¼‰
                        pass
                else:
                    if pos['sl'] > pos['price_open']:
                        # ã‚¹ãƒˆãƒƒãƒ—ãƒ­ã‚¹ã‚’å»ºå€¤ã«æ›´æ–°ï¼ˆå®Ÿè£…çœç•¥ï¼‰
                        pass
    
    def run(self, check_interval: int = 60):
        """EAã‚’å®Ÿè¡Œ"""
        
        self.running = True
        print(f"ğŸ”¥ Self-EA v1.0 èµ·å‹•")
        print(f"   ã‚·ãƒ³ãƒœãƒ«: {self.symbol}")
        print(f"   ã‚¿ã‚¤ãƒ ãƒ•ãƒ¬ãƒ¼ãƒ : {self.timeframe}")
        print(f"   ãƒªã‚¹ã‚¯: {self.risk_percent}%")
        
        while self.running:
            try:
                # ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã‚·ã‚°ãƒŠãƒ«ã‚’ãƒã‚§ãƒƒã‚¯
                signal = self.check_entry_signal()
                if signal:
                    self.execute_trade(signal)
                
                # æ—¢å­˜ãƒã‚¸ã‚·ãƒ§ãƒ³ã‚’ç®¡ç†
                self.manage_positions()
                
                # æ¬¡ã®ãƒã‚§ãƒƒã‚¯ã¾ã§å¾…æ©Ÿ
                time.sleep(check_interval)
                
            except KeyboardInterrupt:
                print("\nâš ï¸ Self-EA v1.0 åœæ­¢ä¸­...")
                self.running = False
            except Exception as e:
                print(f"âŒ ã‚¨ãƒ©ãƒ¼: {e}")
                time.sleep(check_interval)
        
        self.connector.shutdown()
        print("âœ… Self-EA v1.0 åœæ­¢å®Œäº†")
    
    def stop(self):
        """EAã‚’åœæ­¢"""
        self.running = False
```

---

### 5. ãƒ¡ã‚¤ãƒ³ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ (`main.py`)

```python
"""
MT5 TRADING OS vâˆ - Main Entry Point
TENMON-ARKéœŠæ ¸OSçµ±åˆãƒˆãƒ¬ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ 
"""

import os
from dotenv import load_dotenv
from self_ea import SelfEA

def main():
    """ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œé–¢æ•°"""
    
    # ç’°å¢ƒå¤‰æ•°ã‚’èª­ã¿è¾¼ã¿
    load_dotenv()
    
    MT5_LOGIN = int(os.getenv('MT5_LOGIN', '0'))
    MT5_PASSWORD = os.getenv('MT5_PASSWORD', '')
    MT5_SERVER = os.getenv('MT5_SERVER', '')
    
    if MT5_LOGIN == 0 or not MT5_PASSWORD or not MT5_SERVER:
        print("âŒ MT5æ¥ç¶šæƒ…å ±ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“")
        print("   .envãƒ•ã‚¡ã‚¤ãƒ«ã«ä»¥ä¸‹ã‚’è¨­å®šã—ã¦ãã ã•ã„:")
        print("   MT5_LOGIN=ã‚ãªãŸã®ãƒ­ã‚°ã‚¤ãƒ³ID")
        print("   MT5_PASSWORD=ã‚ãªãŸã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰")
        print("   MT5_SERVER=ã‚ãªãŸã®ã‚µãƒ¼ãƒãƒ¼å")
        return
    
    # Self-EA v1.0ã‚’åˆæœŸåŒ–
    ea = SelfEA(
        symbol="USDJPY",
        timeframe=15,  # M15
        risk_percent=1.0,
        max_positions=3
    )
    
    if not ea.initialize(MT5_LOGIN, MT5_PASSWORD, MT5_SERVER):
        print("âŒ Self-EA v1.0ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ")
        return
    
    # EAã‚’å®Ÿè¡Œ
    ea.run(check_interval=60)

if __name__ == "__main__":
    main()
```

---

## ğŸ“¦ å¿…è¦ãªãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ (`requirements.txt`)

```
MetaTrader5==5.0.45
numpy==1.24.3
pandas==2.0.3
scikit-learn==1.3.0
python-dotenv==1.0.0
```

---

## ğŸš€ å®Ÿè£…æ‰‹é †

### 1. Pythonç’°å¢ƒã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—

```bash
# ä»®æƒ³ç’°å¢ƒã‚’ä½œæˆ
python -m venv venv

# ä»®æƒ³ç’°å¢ƒã‚’æœ‰åŠ¹åŒ–
# Windows
venv\Scripts\activate
# macOS/Linux
source venv/bin/activate

# ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
pip install -r requirements.txt
```

### 2. MT5æ¥ç¶šæƒ…å ±ã®è¨­å®š

`.env`ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆï¼š

```env
MT5_LOGIN=ã‚ãªãŸã®MT5ãƒ­ã‚°ã‚¤ãƒ³ID
MT5_PASSWORD=ã‚ãªãŸã®MT5ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰
MT5_SERVER=ã‚ãªãŸã®MT5ã‚µãƒ¼ãƒãƒ¼å
```

### 3. Self-EA v1.0ã®èµ·å‹•

```bash
python main.py
```

---

## ğŸ”¥ TENMON-ARKéœŠæ ¸OSã¨ã®çµ±åˆ

### tRPC Procedureã®å®Ÿè£…

```typescript
// server/routers/mt5Router.ts
import { router, protectedProcedure } from "../_core/trpc";
import { z } from "zod";
import { spawn } from "child_process";
import path from "path";

export const mt5Router = router({
  // Self-EA v1.0ã‚’èµ·å‹•
  startEA: protectedProcedure
    .input(z.object({
      symbol: z.string(),
      timeframe: z.number(),
      riskPercent: z.number(),
    }))
    .mutation(async ({ input }) => {
      // Python Bridgeã‚’èµ·å‹•
      const pythonProcess = spawn('python', [
        path.join(__dirname, '../../mt5_trading_os/main.py')
      ], {
        env: {
          ...process.env,
          MT5_SYMBOL: input.symbol,
          MT5_TIMEFRAME: input.timeframe.toString(),
          MT5_RISK_PERCENT: input.riskPercent.toString(),
        }
      });

      return { success: true, message: "Self-EA v1.0èµ·å‹•" };
    }),

  // ç¾åœ¨ã®ãƒã‚¸ã‚·ãƒ§ãƒ³ã‚’å–å¾—
  getPositions: protectedProcedure.query(async () => {
    // Python Bridgeã‹ã‚‰ãƒã‚¸ã‚·ãƒ§ãƒ³æƒ…å ±ã‚’å–å¾—
    // å®Ÿè£…çœç•¥
    return [];
  }),

  // ãƒˆãƒ¬ãƒ¼ãƒ‰ãƒ­ã‚°ã‚’å–å¾—
  getTradeLog: protectedProcedure.query(async () => {
    // Python Bridgeã‹ã‚‰ãƒˆãƒ¬ãƒ¼ãƒ‰ãƒ­ã‚°ã‚’å–å¾—
    // å®Ÿè£…çœç•¥
    return [];
  }),
});
```

---

## ğŸ“Š ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰UIè¨­è¨ˆ

### MT5ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰

```typescript
// client/src/pages/MT5Dashboard.tsx
import { trpc } from "@/lib/trpc";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";

export default function MT5Dashboard() {
  const startEA = trpc.mt5.startEA.useMutation();
  const { data: positions } = trpc.mt5.getPositions.useQuery();
  const { data: tradeLog } = trpc.mt5.getTradeLog.useQuery();

  return (
    <div className="container py-8">
      <h1 className="text-3xl font-bold mb-8">MT5 TRADING OS vâˆ</h1>
      
      <Card className="p-6 mb-8">
        <h2 className="text-xl font-semibold mb-4">Self-EA v1.0</h2>
        <Button
          onClick={() => startEA.mutate({
            symbol: "USDJPY",
            timeframe: 15,
            riskPercent: 1.0,
          })}
        >
          ğŸ”¥ Self-EA v1.0ã‚’èµ·å‹•
        </Button>
      </Card>

      <Card className="p-6 mb-8">
        <h2 className="text-xl font-semibold mb-4">ç¾åœ¨ã®ãƒã‚¸ã‚·ãƒ§ãƒ³</h2>
        {/* ãƒã‚¸ã‚·ãƒ§ãƒ³ä¸€è¦§ã‚’è¡¨ç¤º */}
      </Card>

      <Card className="p-6">
        <h2 className="text-xl font-semibold mb-4">ãƒˆãƒ¬ãƒ¼ãƒ‰ãƒ­ã‚°</h2>
        {/* ãƒˆãƒ¬ãƒ¼ãƒ‰ãƒ­ã‚°ã‚’è¡¨ç¤º */}
      </Card>
    </div>
  );
}
```

---

## ğŸŒ• å®Œäº†çŠ¶æ…‹

**MT5 TRADING OS vâˆ ã®å†…éƒ¨æ§‹æ–‡ã¯100%å®Œæˆã—ã¾ã—ãŸã€‚**

DNSåæ˜ å¾Œã€ä»¥ä¸‹ã®æ‰‹é †ã§å³å®Ÿè£…å¯èƒ½ï¼š

1. âœ… Python Bridgeå®Œæˆ
2. âœ… Self-EA v1.0æˆ¦ç•¥æ§‹æ–‡å®Œæˆ
3. âœ… Twin-Core Ã— ç«æ°´ Ã— å®¿æ›œã®å¸‚å ´è§£æå®Œæˆ
4. âœ… æœªæ¥è¶³æ¨å®šã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å®Œæˆ
5. âœ… MT5æ¥ç¶šæ‰‹é †å®Œæˆ
6. âœ… tRPCçµ±åˆè¨­è¨ˆå®Œæˆ
7. âœ… ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰UIè¨­è¨ˆå®Œæˆ

**ã€Œå¤–ç•ŒãŒæ•´ã†å‰ã«ã€å†…ç•Œã®å…¨ã¦ã‚’æ•´ãˆãŸã€‚ã€**

---

**è¨­è¨ˆå®Œäº†æ—¥æ™‚**: 2025-01-31  
**æ¬¡å›æ›´æ–°**: DNSåæ˜ å¾Œã®å®Ÿè£…ãƒ•ã‚§ãƒ¼ã‚º
